package pricemigrationengine.migrations.newspaper2024Migration
import pricemigrationengine.model._

import java.time.LocalDate
import pricemigrationengine.util.Date

object Estimation {

  // --------------------------------------------------------------------------------------------

  // RatePlanDetails was introduced to help properly test the data gathering to build the PriceData
  // It turned out to be particularly useful for testing that the logic was correct
  // It is currently limited to Newspaper2024Migration, but could be generalised to other (future) migrations
  case class SubscriptionData2024(
      productName: String,
      ratePlan: ZuoraRatePlan,
      ratePlanName: String,
      billingPeriod: BillingPeriod,
      currency: String,
      currentPrice: BigDecimal,
      targetRatePlanId: String,
  )

  // We have an unusual scheduling for this migration and Newspaper2024BatchId is used to
  // decide the correct start date for each subscription.
  sealed trait Newspaper2024BatchId
  object MonthliesPart1 extends Newspaper2024BatchId // First batch of monthlies
  object MonthliesPart2 extends Newspaper2024BatchId // Second batch of monthlies
  object MoreThanMonthlies extends Newspaper2024BatchId // Quarterlies, Semi-Annuals and Annuals

  def ratePlanLastChangeTypeIsNoneOrAdd(ratePlan: ZuoraRatePlan): Boolean = {
    ratePlan.lastChangeType.isEmpty || ratePlan.lastChangeType.contains("Add")
  }

  def subscriptionToMigrationProductName(subscription: ZuoraSubscription): Either[String, String] = {
    // We are doing a multi product migration. This function tries and retrieve the correct product given a
    // subscription.
    val migrationProductNames = List("Newspaper Delivery", "Newspaper Digital Voucher", "Newspaper Voucher")
    val names = subscription.ratePlans
      .filter(ratePlanLastChangeTypeIsNoneOrAdd)
      .map(ratePlan => ratePlan.productName)
      .filter(name => migrationProductNames.contains(name))
      .distinct
    names match {
      case Nil =>
        Left(
          s"[error: d5fb6922] could not determine migration product name for subscription ${subscription.subscriptionNumber}; no name to choose from"
        )
      case name :: Nil => Right(name)
      case _ =>
        Left(
          s"[error: d3ecd18d] could not determine migration product name for subscription ${subscription.subscriptionNumber}; more than one name to choose from"
        )
    }
  }

  def subscriptionToSubscriptionData2024(subscription: ZuoraSubscription): Either[String, SubscriptionData2024] = {
    val productName = subscriptionToMigrationProductName(subscription).toOption.get
    val ratePlans = {
      subscription.ratePlans
        .filter(ratePlan => ratePlan.productName == productName)
        .filter(ratePlanLastChangeTypeIsNoneOrAdd)
        .distinct
    }
    ratePlans match {
      case Nil =>
        Left(
          s"[error 93a21a48] Subscription ${subscription.subscriptionNumber} was found to have zero newsPaperDeliveryRatePlans making determination of rate plan name impossible"
        )
      case ratePlan :: Nil => {
        (for {
          billingPeriod <- ZuoraRatePlan.ratePlanToBillingPeriod(ratePlan)
          currency <- ZuoraRatePlan.ratePlanToCurrency(ratePlan)
          currentPrice = ratePlan.ratePlanCharges.foldLeft(BigDecimal(0))(
            (price: BigDecimal, ratePlanCharge: ZuoraRatePlanCharge) =>
              price + ratePlanCharge.price.getOrElse(BigDecimal(0))
          )
          targetRatePlanId <- StaticData.ratePlanIdLookUp(productName, ratePlan.ratePlanName)
        } yield SubscriptionData2024(
          productName = productName,
          ratePlan = ratePlan,
          ratePlanName = ratePlan.ratePlanName,
          billingPeriod = billingPeriod,
          currency = currency,
          currentPrice = currentPrice,
          targetRatePlanId = targetRatePlanId
        )).toRight(s"[error: 0e218c37] Could not determine SubscriptionData2024 for subscription ${subscription}")
      }
      case _ =>
        Left(
          s"[error 93a21a48] Subscription ${subscription.subscriptionNumber} was found to have more than one newsPaperDeliveryRatePlans making determination of rate plan name impossible"
        )
    }
  }

  def subscriptionToNewPrice(subscription: ZuoraSubscription): Option[BigDecimal] = {
    // The price correction factor is meant to be 1 except in the case of
    // subscriptions with capping in which case the correction factor will have been precomputed
    // from the data generated by Matt
    val priceCorrectionFactor = PriceCapping.priceCorrectionFactor(subscription)
    for {
      data2024 <- subscriptionToSubscriptionData2024(subscription).toOption
      price <- StaticData.priceLookup(
        data2024.productName,
        data2024.billingPeriod,
        data2024.ratePlanName
      )
    } yield price * priceCorrectionFactor
  }

  def priceData(
      subscription: ZuoraSubscription,
  ): Either[AmendmentDataFailure, PriceData] = {
    for {
      data2024 <- subscriptionToSubscriptionData2024(subscription).left.map(AmendmentDataFailure)
      oldPrice = data2024.currentPrice
      newPrice <- subscriptionToNewPrice(subscription).toRight(AmendmentDataFailure("error"))
    } yield PriceData(
      data2024.currency,
      oldPrice,
      newPrice,
      BillingPeriod.toString(data2024.billingPeriod)
    )
  }

  def subscriptionToBatchId(subscription: ZuoraSubscription): Either[String, Newspaper2024BatchId] = {

    def ratePlanChargesToBatchId(list: List[ZuoraRatePlanCharge]): Either[String, Newspaper2024BatchId] = {
      list match {
        case Nil => Left(s"Could not extract a rate plan charge for subscription: ${subscription.subscriptionNumber}")
        case rpc :: _ => {
          val monthIndex = rpc.chargedThroughDate.getOrElse(LocalDate.of(2024, 1, 1)).getDayOfMonth
          if (monthIndex <= 20) {
            Right(MonthliesPart2)
          } else {
            Right(MonthliesPart1)
          }
        }
      }
    }

    for {
      subscriptionData <- subscriptionToSubscriptionData2024(subscription)
      batchId <- {
        subscriptionData.billingPeriod match {
          case Monthly => {
            val ratePlan = subscriptionData.ratePlan
            ratePlanChargesToBatchId(ratePlan.ratePlanCharges)
          }
          case _ => Right(MoreThanMonthlies)
        }
      }
    } yield batchId
  }

  def batchIdToEarliestMigrationStartDate(batchId: Newspaper2024BatchId): LocalDate = {
    batchId match {
      case MonthliesPart1    => LocalDate.of(2024, 2, 21) // 21 Feb 2024
      case MonthliesPart2    => LocalDate.of(2024, 3, 18) // 18 March 2024
      case MoreThanMonthlies => LocalDate.of(2024, 3, 1) // 1 March 2024
    }
  }

  def subscriptionToEarliestMigrationStartDate(subscription: ZuoraSubscription): LocalDate = {
    subscriptionToBatchId(subscription) match {
      case Right(bid)   => batchIdToEarliestMigrationStartDate(bid)
      case Left(string) => LocalDate.of(2024, 4, 1)
      // Default date to avoid returning a more complex value than a LocalDate
    }
  }

  def startDateLowerbound(
      today: LocalDate,
      subscription: ZuoraSubscription
  ): LocalDate = {
    val earliestPriceMigrationStartDate = subscriptionToEarliestMigrationStartDate(subscription)

    Date.datesMax(
      earliestPriceMigrationStartDate,
      today.plusDays(
        StaticData.minLeadTime + 1
      ) // +1 because we need to be strictly over minLeadTime days away. Exactly minLeadTime is not enough.
    )
  }

  def startDateSpreadPeriod(subscription: ZuoraSubscription): Int = {
    subscriptionToBatchId(subscription) match {
      case Right(MonthliesPart1)    => 1
      case Right(MonthliesPart2)    => 2
      case Right(MoreThanMonthlies) => 1
      case Left(_)                  => 1
    }
  }
}
